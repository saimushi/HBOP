<?php

class FlowManager
{
	public static $params = NULL;

	/**
	 * 定義情報をチェックする
	 * @param unknown $argContainerXML
	 */
	public static function validate($argContainerXML){
		return TRUE;
	}

	/**
	 * 定義情報をチェックする
	 * @param string XMLファイルのパス文字列 or XML文字列
	 */
	public static function generate($argTarget, $argSection){
		$filepathUsed = FALSE;
		$targetXML = $argTarget;
		if(1024 >= strlen($argTarget) && TRUE === file_exists_ip($argTarget)){
			// ファイルパス指定の場合はファイルの中身を文字列として一旦取得
			$filepathUsed = TRUE;
			$targetXML = file_get_contents($argTarget);
		}
		// クラス名を確定する
		$className = $argSection;
		if(TRUE === $filepathUsed){
			// オートジェネレートフラグの取得(フレームワークのコアから貰う)
			$autoGenerateFlag = getAutoGenerateEnabled();
			if(TRUE === $autoGenerateFlag){
				$generatedClassPath = self::_getAutogenerateFilePath($argTarget);
				// unlinkされたか
				if(FALSE === resolveUnlinkAutoGeneratedFile($generatedClassPath)){
					// クラス名を返して終了
					return $className;
				}
			}
		}
		// XML文字列を、XMLオブジェクト化
		libxml_use_internal_errors(TRUE);
		$FlowXML = simplexml_load_string($targetXML);
		if(FALSE === $FlowXML){
			throw new LibXMLException(libxml_get_errors());
		}
		// FlowXMLとして正しいかどうか
		if(TRUE === self::validate($FlowXML)){
			// $argSectionがIndex_authedだったとして、index-authedに変換される
			//$targetSection = str_replace('_', '-', ucfirst($argSection));
			// FlowXMLに基いてコントローラクラスを自動生成する
			$classDef = '';
			foreach ($FlowXML->children() as $firstNode) {
				// firstNodeのid属性から暮らす名を決める
				// idがindex-authedだったとして、Index_authedに変換される
				$tmpAttr = $firstNode->attributes();
				$sectionClassName = str_replace('-', '_', ucfirst($tmpAttr['id']));
				// 上位クラスは暫定でWebコントローラと言う事にする
				$extends = ' extends WebControllerBase';
				// 上位クラスが指定されているかどうか
				if(isset($tmpAttr['extends']) && strlen($tmpAttr['extends']) > 0){
					// そのまま採用
					$extends = ' extends ' . $tmpAttr['extends'];
				}
				// コントローラセクションのタイプ属性が指定されているかどうか
				elseif(isset($tmpAttr['type']) && strlen($tmpAttr['type']) > 0){
					if('web' === $tmpAttr['type']){
						$extends = ' extends WebControllerBase';
					}
					elseif('api' === $tmpAttr['type']){
						$extends = ' extends APIControllerBase';
					}
					elseif('image' === $tmpAttr['type']){
						$extends = ' extends ImageControllerBase';
					}
				}
				$methods = array();
				// メソッド定義
				foreach ($firstNode->children() as $methodNode) {
					// 2次元目はメソッド定義
					$methodName = $methodNode->getName();
					// constructとdestructだけをマジックメソッドのマップとしてサポートする
					if('construct' == $methodName || 'destruct' == $methodName){
						$methodName = '__' . $methodName;
					}
					$method = PHP_TAB . 'function ' . $methodName . '(%s){' . PHP_EOL . '%s' . PHP_EOL . PHP_TAB . PHP_TAB . 'return TRUE;' . PHP_EOL . PHP_TAB . '}' . PHP_EOL;
					$methodArg = '';
					$methodArgs = $methodNode->attributes();
					if(count($methodArgs) > 0){
						$methodArg = array();
						foreach($methodArgs as $key => $val){
							$arg = '';
							$arg .= '$' . $key . ' = ' . self::_resolveValue($val);
							$methodArg[] = $arg;
						}
						$methodArg = implode(', ', $methodArg);
					}
					// 3次元目は以降はネスト構造のソースコード定義
					$code = '';
					foreach ($methodNode->children() as $codeNode) {
						$code .= self::_generateCode($codeNode);
					}
					$method = sprintf($method, $methodArg, $code);
					$methods[] = $method;
				}
				// クラス定義つなぎ合わせ
				$classDef .= PHP_EOL . 'class ' . $sectionClassName . $extends . PHP_EOL;
				$classDef .= '{' . PHP_EOL;
				for($methodIdx=0; count($methods) > $methodIdx; $methodIdx++){
					$classDef .= $methods[$methodIdx];
				}
				$classDef .= '}' . PHP_EOL;
			}
			// オートジェネレートチェック
			if(TRUE === $filepathUsed && TRUE === $autoGenerateFlag){
				// 空でジェネレートファイルを生成
				@file_put_contents($generatedClassPath, '');
				// ジェネレート
				generateClassCache($generatedClassPath, $argTarget, $classDef, $className);
				// 静的ファイル化されたクラスファイルを読み込んで終了
				// fatal errorがいいのでrequireする
				//require_once $generatedClassPath;
			}
			// オートジェネレートが有効だろうが無効だろうがココまで来たらクラス定義の実体化
			eval($classDef);
			return $className;
		}
		return FALSE;
	}

	/**
	 * ジェネレートファイルのターゲットパスを取得する
	 * @param unknown $argNode
	 */
	public static function _getAutogenerateTargetPath($argTarget){
		$targetPath = str_replace('..','.', str_replace('/','.', substr($argTarget, strlen(MVCCore::$flowXMLBasePath))));
		if(0 === strpos($targetPath, '.')){
			$targetPath = substr($targetPath, 1);
		}
		return $targetPath;
	}

	/**
	 * ジェネレートファイルのパスを取得する
	 * @param unknown $argNode
	 */
	public static function _getAutogenerateFilePath($argTarget){
		return getAutoGeneratedPath() . self::_getAutogenerateTargetPath($argTarget) . '.generated.inc.php';
	}

	/**
	 * ノードを処理に分解する
	 * @param unknown $argNode
	 */
	public static function _generateCode($argCodeNode, $argDepth=1){
		if(isset($argCodeNode) && NULL !== $argCodeNode){
			// TAB
			$tab = PHP_TAB;
			for ($depthIdx=0; $depthIdx < $argDepth; $depthIdx++){
				$tab .= PHP_TAB;

			}
			$code = $tab;
			$codeType = $argCodeNode->getName();
			$tmpAttr = $argCodeNode->attributes();
			// コードの種類に応じて処理を分岐
			if('flow' === $codeType){
				// 次のフローを実行する処理を生成
				$code .= '$instance = new ' . str_replace('-', '_', ucfirst($tmpAttr['section'])) . '();' . PHP_EOL;
				// Flowなので、処理の移譲先のコントローラに自身のクラス変数を適用し直す
				$code .= $tab . '$instance->controlerClassName = \'' . $tmpAttr['section'] . '\';' . PHP_EOL;
				$code .= $tab . '$instance->httpStatus = $this->httpStatus;' . PHP_EOL;
				$code .= $tab . '$instance->outputType = $this->outputType;' . PHP_EOL;
				$code .= $tab . '$instance->jsonUnescapedUnicode = $this->jsonUnescapedUnicode;' . PHP_EOL;
				$code .= $tab . '$instance->deviceType = $this->deviceType;' . PHP_EOL;
				$code .= $tab . '$instance->appVersion = $this->appVersion;' . PHP_EOL;
				$code .= $tab . '$instance->appleReviewd = $this->appleReviewd;' . PHP_EOL;
				$code .= $tab . '$instance->mustAppVersioned = $this->mustAppVersioned;' . PHP_EOL;
				// Flowクラスのメソッド実行の追記
				$method = 'execute';
				if(isset($tmpAttr['method']) && strlen($tmpAttr['method']) > 0){
					$method = $tmpAttr['method'];
				}
				$code .= $tab . '$res = $instance->' . $method . '(' . self::_resolveArgs($tmpAttr) .  ');' . PHP_EOL;
				// Flowなので、処理を移譲した先のコントローラの最終結果クラス変数を自分自身に適用し直す
				$code .= $tab . '$this->httpStatus = $instance->httpStatus;' . PHP_EOL;
				$code .= $tab . '$this->outputType = $instance->outputType;' . PHP_EOL;
				$code .= $tab . '$this->jsonUnescapedUnicode = $instance->jsonUnescapedUnicode;' . PHP_EOL;
				$code .= $tab . '$this->deviceType = $instance->deviceType;' . PHP_EOL;
				$code .= $tab . '$this->appVersion = $instance->appVersion;' . PHP_EOL;
				$code .= $tab . '$this->appleReviewd = $instance->appleReviewd;' . PHP_EOL;
				$code .= $tab . '$this->mustAppVersioned = $instance->mustAppVersioned;' . PHP_EOL;
				$code .= $tab . 'return $res;';
			}
			elseif('view' === $codeType){
				$target = '\'\'';
				if(isset($tmpAttr['target']) && strlen($tmpAttr['target']) > 0){
					$target = self::_resolveValue($tmpAttr['target']);
				}
				// Viewを表示する処理を生成
				$code .= '$html = Core::loadView(str_replace(\'_\', \'-\', $this->controlerClassName), FALSE, ' . $target . ')->execute(NULL, Flow::$params);' . PHP_EOL;
				$code .= $tab . 'return $html;';
			}
			else{
				// それ以外はXML化されたただのPHPコード扱い
				// XXX 状態遷移して生成して行くので、処理の順番に注意！
				// if文
				if('if' === $codeType){
					$code .= 'if(';
				}
				elseif('elseid' === $codeType){
					$code .= 'elseif(';
				}
				elseif('else' === $codeType){
					$code .= 'else';
				}
				elseif('return' === $codeType){
					$code .= 'return ';
				}
				if(isset($tmpAttr['var']) && strlen($tmpAttr['var']) > 0){
					$code .= '$' . $tmpAttr['var'];
				}
				// 式の評価文
				// if文 elseif文
				if('if' === $codeType || 'elseif' === $codeType){
					// 評価方法判定
					if(isset($tmpAttr['style'])){
						$code .= ' ' . $tmpAttr['style'] . ' ';
					}
					// それ以外は透等価判定
					else{
						$code .= ' === ';
					}
				}
				// else文
				elseif('else' === $codeType){
					// elseは何もナシ
				}
				// return文
				elseif('return' === $codeType){
					// returnは何もナシ
				}
				// それ以外は代入扱い
				else {
					$code .= ' = ';
				}
				// 式の右辺属性文
				if('new' === $codeType){
					$code .= 'new ';
				}
				// 右辺が変数の場合
				if(isset($tmpAttr['val']) && strlen($tmpAttr['val']) > 0){
					$code .= self::_resolveValue($tmpAttr['val']);
				}
				// 右辺がクラスの場合
				if(isset($tmpAttr['class']) && strlen($tmpAttr['class']) > 0){
					$code .= $tmpAttr['class'];
					if('new' === $codeType){
						$code .= '(' . self::_resolveArgs($tmpAttr) . ')';
					}
					else{
						$code .= '::';
					}
				}
				// 右辺がインスタンス化されたクラスの場合
				if(isset($tmpAttr['instance']) && strlen($tmpAttr['instance']) > 0){
					$code .= '$' . $tmpAttr['instance'] . '->';
				}
				// メソッド定義を繋げる
				if(isset($tmpAttr['method']) && strlen($tmpAttr['method']) > 0){
					$code .= $tmpAttr['method'] . '(' . self::_resolveArgs($tmpAttr) . ')';
				}
				// 式の終端文
				if('if' === $codeType || 'elseif' === $codeType){
					$code .= '){' . PHP_EOL;
				}
				elseif('else' === $codeType){
					$code .= '{' . PHP_EOL;
				}
				// ネスト構造を再帰的に処理して、コードに繋げる
				if(count($argCodeNode->children()) > 0){
					foreach($argCodeNode->children() as $codeNode){
						$code .= self::_generateCode($codeNode, ($argDepth+1));
					}
				}
				// 終了子判定
				if('if' === $codeType || 'elseif' === $codeType || 'else' === $codeType){
					$code .= $tab . '}';
				}
				else{
					$code .= ';';
				}
			}
			// 生成されたコードを返す
			return $code . PHP_EOL;
		}
		// 何も生成してないので、0バイト文字を返す
		return '';
	}

	/**
	 * 引数の値の解決処理
	 * @param unknown $argNode
	 */
	public static function _resolveArgs($argAttr){
		$argCnt = 1;
		$code = '';
		while(isset($argAttr['arg' . $argCnt])){
			if($argCnt > 1){
				$code .= ', ';
			}
			$code .= self::_resolveValue($argAttr['arg' . $argCnt]);
			$argCnt++;
		}
		return $code;
	}

	/**
	 * 属性の値の解決処理
	 * @param unknown $argNode
	 */
	public static function _resolveValue($argValue){
		$val = $argValue;
		if(strpos($val, 'assign:')){
			$val = '$' . $val;
		}
		elseif('true' === strtolower($val)){
			$val = 'TRUE';
		}
		elseif('false' === strtolower($val)){
			$val = 'FALSE';
		}
		elseif('null' === strtolower($val)){
			$val = 'NULL';
		}
		elseif(TRUE === is_numeric($val)){
			$val = (string)$val;
		}
		elseif(0 === strpos($val, 'string:')){
			$val = substr($val, 7);
			$val = '\'' . $val . '\'';
		}
		elseif(0 === strpos($val, 'str:')){
			$val = substr($val, 4);
			$val = '\'' . $val . '\'';
		}
		return $val;
	}
}
?>