<?php

// このファイルのファイル名を持ってしてフレームワークの名称と位置づける
// 名前は変えてOKです
function corefilename(){
	return strtoupper(substr(basename(__FILE__), 0, strpos(basename(__FILE__), '.')));
}

// この手続上でコアファイル名(フレームワーク名)へのアクセスが何度も出てくるので変数に入れておく
$corefilename = corefilename();

// 定数定義
define('PHP_TAB', "\t");
define('PHP_CR', "\r");
define('PHP_LF', "\n");

// XXX config.xmlを別パスに設置したい場合は以下の定数を定義すればOK(絶対パスでの定義)
//define($corefilename . '_CONFIG_XML_PATH', dirname(__FILE__).'/' . $corefilename . '.config.xml');
// XXX 強制終了時に閉鎖処理を入れたい場合は以下の定数に関数名を指定する事！引数は渡せないので工夫する事！
//define($corefilename . '_ERROR_FINALIS', 'finalize');

// XXX 各種フラグファイルを別パスに設置したい場合は以下の定数を定義すればOK(絶対パスでの定義)
// 自動ジェネレート(高速化用静的ファイル変換)のセット
//define($corefilename . '_AUTO_GENERATE_ENABLED', dirname(dirname(__FILE__)).'/.autogenerate');
// 自動ジェネレート(高速化用静的ファイル変換)のセット
//define($corefilename . '_AUTO_MIGRATE_ENABLED', dirname(dirname(__FILE__)).'/.automigrate');
// ローカル環境フラグのセット
//define($corefilename . '_STAGE_LOCAL_ENABLED', dirname(dirname(__FILE__)).'/.local');
// 開発環境フラグのセット
//define($corefilename . '_STAGE_DEV_ENABLED', dirname(dirname(__FILE__)).'/.dev');
// テスト環境(テスト用凍結環境)フラグのセット
//define($corefilename . '_STAGE_TEST_ENABLED', dirname(dirname(__FILE__)).'/.test');
// ステージング環境フラグのセット
//define($corefilename . '_STAGE_STAGING_ENABLED', dirname(dirname(__FILE__)).'/.staging');
// デバッグモードのセット
//define($corefilename . '_DEBUG_MODE_ENABLED', dirname(dirname(__FILE__)).'/.debug');
// エラーレポートのセット
//define($corefilename . '_ERROR_REPORT_ENABLED', dirname(dirname(__FILE__)).'/.error_report');

/*------------------------------ 根幹関数定義 ココから ------------------------------*/

/**
 * クラス使用時、ロードされてないと実行される
 * @param string $className
*/
function _autoloadFramework($className){
	//
	if(!class_exists($className, FALSE)){
		// class_existsから呼びだされたのかの判定
		$class_exists_called = FALSE;
		$dbg = debug_backtrace();
		if(isset($dbg[2]) && isset($dbg[2]['function']) && 'class_exists' == $dbg[2]['function']){
			$class_exists_called = TRUE;
		}
		// バックトレースは重いのでとっとと捨てる
		unset($dbg);
		// 		$res = FALSE;
		// 		if(class_exists('MVCCore', FALSE)){
		// 			// フレームワークの'MVCCore'クラスが読み込まれていたらMVCのloadを先ず実行してみる
		// 			$res = MVCCore::loadMVCModule($className, TRUE);
		// 		}
		// 		// クラスファイルの読み込み
		// 		if(FALSE === $res){
		loadModule($className, $class_exists_called);
		// 		}
	}
}

// オートローダへ登録
spl_autoload_register('_autoloadFramework');

$functions = <<<_METHODS_
if (!function_exists('filemtime_ip')){
	/**
	 * filemtimeでinclude_pathを走査する
	 * ※フレームワーク内で使用しているので注意！
	 */
	function filemtime_ip(\$argFilePath){
		\$time = (int)@filemtime(\$argFilePath);
		if(0 === \$time){
			\$includePaths = explode(PATH_SEPARATOR, get_include_path());
			for(\$includePathNum=0; \$includePathNum < count(\$includePaths); \$includePathNum++){
				\$time = (int)@filemtime(\$includePaths[\$includePathNum].\$argFilePath);
				if(0 < \$time){
					BREAK;
				}
			}
		}
		return \$time;
	}
}

if (!function_exists('file_exists_ip')){
	/**
	 * file_existsでinclude_pathを走査する
	 * ※フレームワーク内で使用しているので注意！
	 */
	function file_exists_ip(\$argFilePath){
		\$exists = @file_exists(\$argFilePath);
		if(TRUE !== \$exists){
			\$includePaths = explode(PATH_SEPARATOR, get_include_path());
			for(\$includePathNum=0; \$includePathNum < count(\$includePaths); \$includePathNum++){
				\$exists = @file_exists(\$includePaths[\$includePathNum].\$argFilePath);
				if(TRUE === \$exists){
					BREAK;
				}
			}
		}
		return \$exists;
	}
}
_METHODS_;

// オートジェネレートキャッシュ用に関数定義を文字列として取っておく
define('FILE_CHECK_GENERIC_FUNCTIONS', $functions);
eval($functions);

/**
 * HAPPYBORN OOP/AOP向けフレームワークのほぼ本体
 * クラス・関数の自動走査・自動読み込み・自動生成を行う
 * @param string モジュール本体を探すヒント文字列(URI) or .区切り文字 (混在はNG /がある場合、URIとして優先して処理される）
 * @param bool クラスの存在チェックをからめたコールの場合は、sysエラーで終了せず、エラーをretrunしてあげる
 * @return return instance名を返す
*/
function loadModule($argHint, $argClassExistsCalled = FALSE){

	// オートジェネレートフラグの取得
	$autoGenerateFlag = getAutoGenerateEnabled();
	// パッケージヒント文字列
	$hintPath = str_replace('/', '.', $argHint);
	// パッケージ定義の初期化
	$pkConfXMLs = _initFramework(TRUE);

	// オートジェネレートチェック
	if(TRUE === $autoGenerateFlag){
		$generatedIncFileName = getAutoGeneratedPath().$hintPath.'.generated.inc.php';
		if(FALSE === resolveUnlinkAutoGeneratedFile($generatedIncFileName)){
			// ジェネレートされたファイルを読み込んで終了
			return TRUE;
		}

		// 		if(is_file($generatedIncFileName)){
		// 			$unlink=TRUE;
		// 			if(filemtime($generatedIncFileName) >= filemtime(__FILE__)){
		// 				// フレームワークコアの変更が見当たらない場合は、コンフィグと比較
		// 				for($pkConfXMLCnt = 0, $timecheckNum = 0; count($pkConfXMLs) > $pkConfXMLCnt; $pkConfXMLCnt++){
		// 					// XXX 時間チェック(タイムゾーン変えてもちゃんと動く？？)
		// 					if(filemtime($generatedIncFileName) >= $pkConfXMLs[$pkConfXMLCnt]['time']){
		// 						$timecheckNum++;
		// 					}
		// 				}
		// 				if($timecheckNum === $pkConfXMLCnt){
		// 					$unlink=FALSE;
		// 					// 静的ファイル化されたrequire群ファイルを読み込んで終了
		// 					// fatal errorがいいのでrequireする
		// 					require_once $generatedIncFileName;
		// 				}
		// 			}
		// 			if(FALSE === $unlink){
		// 				// ジェネレートされたファイルを読み込んで終了
		// 				return TRUE;
		// 			}
		// 			// ここまで来たら再ジェネレートが走るのでジェネレート済みの古いファイルを削除しておく
		// 			@file_put_contents($generatedIncFileName, '');
		// 			@unlink($generatedIncFileName);
		// 		}
	}

	// パッケージ名に該当するノードが格納されたパッケージXML格納用
	$pkConfXML = NULL;
	// パッケージ名
	$packageName = NULL;
	// 代表クラス名 本来は必要ないので空
	// ※パッケージ名と実際にパッケージ読み込み後に利用するクラス名が違う場合に利用される
	// ※一つのリンクされたファイルの中に複数のクラス定義がある場合等
	$className = NULL;

	// defaultパッケージの走査は最後 or 明示の時だけに絞る
	$defaultPackageFlag = FALSE;

	// defaultパッケージの明示指定があるかどうか
	$matches = NULL;
	if(preg_match('/^default\.(.+)/', $argHint, $matches)){
		// defaultパッケージを走査対象のパッケージとする
		$defaultPackageFlag = TRUE;
		$packageName = $matches[1];
		$pkConfXML = $pkConfXMLs[0]['dom'];
	}
	else{
		// Hintパスからパッケージを当てる
		if(!is_file($argHint)){
			// 読み込み済みの$pkConfXMLの数分だけ処理
			for($pkConfXMLCnt = 0; count($pkConfXMLs) > $pkConfXMLCnt; $pkConfXMLCnt++){
				$pkConfXML = $pkConfXMLs[$pkConfXMLCnt]['dom'];
				if(isset($pkConfXML->{$argHint})){
					// ※見つかった！
					// Hintのパス情報そのままの定義があればそれを使う
					$packageName = $argHint;
					BREAK;
				}
				// ※まだ見つからない！
				// パッケージXMLの子ノード総当りでパターンマッチ検索
				foreach(get_object_vars($pkConfXML) as $key => $ChildNode){
					if(isset($ChildNode->pattern) && preg_match('/'.$ChildNode->pattern.'/', $argHint)){
						// ※見つかった！
						$packageName = $key;
						// ルートのループも含めてスキップ
						BREAK 2;
					}
				}
				// ※まだ見つからない！
				// Hintのパス情報からたどる
				$pathHints = explode('/', $argHint);
				if(count($pathHints) == 0){
					$pathHints = explode('.', $argHint);
				}
				$pathHintMaxCnt = count($pathHints);
				// XXX コレなーんか処理おかしい気がする・・・後ろから回すべきじゃね？？
				// hintの長い状態から上を徐々に削って短くし、完全一致する場所を探す
				for($pathHintCnt = 0; $pathHintMaxCnt > $pathHintCnt; $pathHintCnt++){
					$packageName = implode('.', $pathHints);
					if(isset($pkConfXML->{$packageName})){
						// ※見つかった！
						// ルートのループも含めてスキップ
						BREAK 2;
					}
					// 見つからないのでやり直し
					$packageName = NULL;
					unset($pathHints[$pathHintCnt]);
				}
			}
		}
		// ※まだ見つからない！
		if(NULL === $packageName){
			// ここまできてなかったら仮でdefaultパッケージを走査対象のパッケージとする
			$defaultPackageFlag = TRUE;
			$packageName = $argHint;
			$pkConfXML = $pkConfXMLs[0]['dom'];
		}
	}

	// 実際にモジュールを設定したパッケージから設定内容を取得して読み込みを行う
	if(TRUE === $defaultPackageFlag){
		// defaultパッケージを捜査
		_loadDefaultModule($argHint, $argClassExistsCalled, $packageName);
		$className = NULL;
	}
	else{
		// オートジェネレートされるファイルを初期化
		if(TRUE === $autoGenerateFlag){
			// 空でジェネレートファイルを生成
			@file_put_contents($generatedIncFileName, '');
		}
		// 明示的な指定がある場合の捜査
		// パッケージ定義の中に、複数のlinkが設定されていたら、そのlink数分処理をループ
		// linkを全て読み込む
		for($packagePathCnt = 0, $errorCnt = 0; count($pkConfXML->{$packageName}->link) > $packagePathCnt; $packagePathCnt++){
			$fileget = FALSE;
			$addmethod = FALSE;
			$rename = FALSE;
			// メソッドを追加する処理
			if(0 < @strlen($pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->addmethod)){
				$fileget = TRUE;
				$addmethod = TRUE;
			}
			// クラス名をリネームする処理
			if(0 < @strlen($pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->renameto) && 0 < @strlen($pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->renamefrom)){
				$fileget = TRUE;
				$rename = TRUE;
			}
			// ファイルを変数に読み込むかどうか
			if(TRUE === $fileget){
				// 変数に読み込む(addmethodかrenmae処理が予定されている)
				$classdef = @file_get_contents($pkConfXML->{$packageName}->link[$packagePathCnt], TRUE);
				if(strlen($classdef) == 0){
					// 読み込みに失敗した場合、パッケージがハズレだったので_loadDefaultModuleでdefault定義パッケージを走査して貰ってみる事にする
					$subPackageName = $pkConfXML->{$packageName}->link[$packagePathCnt];
					if(preg_match('/^default\.(.+)/', $subPackageName, $matches)){
						$subPackageName = $matches[1];
					}
					// _loadDefaultModuleの再帰処理による自動解決を試みる
					$classdefs = _loadDefaultModule($argHint, $argClassExistsCalled, $subPackageName, TRUE);
					// 読み込みに成功したクラス定義を変数に詰め直す
					// 成功していない場合、ここまで処理が到達しない
					$classdef = $classdefs['classdef'];
					$classPath = $classdefs['classpath'];
				}
				else{
					// 読み込みに成功したクラス定義を変数に詰め直す
					$classPath = $pkConfXML->{$packageName}->link[$packagePathCnt];
				}
			}
			else{
				// ファイルはインクルードで処理する
				if(FALSE === @include_once($pkConfXML->{$packageName}->link[$packagePathCnt])){
					// includeに場合、パッケージがハズレだったので_loadDefaultModuleでdefault定義パッケージを走査して貰ってみる事にする
					$subPackageName = $pkConfXML->{$packageName}->link[$packagePathCnt];
					if(preg_match('/^default\.(.+)/', $subPackageName, $matches)){
						$subPackageName = $matches[1];
					}
					// loadModuleの再帰処理による自動解決を試みる
					_loadDefaultModule($argHint, $argClassExistsCalled, $subPackageName);
				}
				else{
					// ジェネレート処理
					if(TRUE === $autoGenerateFlag){
						generateIncCache($generatedIncFileName, $pkConfXML->{$packageName}->link[$packagePathCnt]);
					}
				}
			}
			// methodの動的追加を実行
			if(TRUE === $addmethod){
				if(!isset($classBuffer)){
					ob_start();
					echo $classdef;
					$classBuffer = ob_get_clean();
				}
				// 追加するメソッド定義を探す
				$addmethoddef = $pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->addmethod;
				if(FALSE !== strpos($addmethoddef, ',')){
					$addmethoddefs = explode(',', $addmethoddef);
					for($addmethoddefIndex=0; count($addmethoddefs) > $addmethoddefIndex; $addmethoddefIndex++){
						if(isset($pkConfXML->{$packageName}->{trim($addmethoddefs[$addmethoddefIndex])}) && isset($pkConfXML->{$packageName}->{trim($addmethoddefs[$addmethoddefIndex])}->attributes()->targetclass) && strlen($pkConfXML->{$packageName}->{trim($addmethoddefs[$addmethoddefIndex])}->attributes()->targetclass) > 0){
							$targetClassName = $pkConfXML->{$packageName}->{trim($addmethoddefs[$addmethoddefIndex])}->attributes()->targetclass;
							$addmethod = (string)$pkConfXML->{$packageName}->{trim($addmethoddefs[$addmethoddefIndex])};
							$classBuffer = preg_replace('/(class|abstract|interface)\s+?'.trim($targetClassName).'(.*)?\{/', '$1 '. trim($targetClassName) . '\2 { '.$addmethod, $classBuffer);
						}
						else{
							_systemError('class method add notfound node \''.$packageName.'.'.trim($addmethoddefs[$addmethoddefIndex]).' or undefined attribute \'targetclass\'');
						}
					}
				}
				else{
					if(isset($pkConfXML->{$packageName}->{$addmethoddef}) && isset($pkConfXML->{$packageName}->{trim($addmethoddef)}->attributes()->targetclass) && strlen($pkConfXML->{$packageName}->{trim($addmethoddef)}->attributes()->targetclass) > 0){
						$targetClassName = $pkConfXML->{$packageName}->{trim($addmethoddef)}->attributes()->targetclass;
						$addmethod = (string)$pkConfXML->{$packageName}->{trim($addmethoddef)};
						$classBuffer = preg_replace('/(class|abstract|interface)\s+?'.trim($targetClassName).'(.*)?\{/', '$1 '. trim($targetClassName) . '\2 { '.$addmethod, $classBuffer);
					}
					else{
						_systemError('class method add notfound node \''.$packageName.'.'.trim($addmethoddef).' or undefined attribute \'targetclass\'');
					}
				}
			}
			// クラス名リネームの実行
			// XXX 処理の順番に注意！！先にaddmethodを処理。renameした後だとクラス名が変わっていてaddにしくじるので
			if(TRUE === $rename){
				if(!isset($classBuffer)){
					ob_start();
					echo $classdef;
					$classBuffer = ob_get_clean();
				}
				// リネーム
				$renametoClassName = $pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->renameto;
				$renamefromClassName = $pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->renamefrom;
				if(FALSE !== strpos($renametoClassName, ',')){
					$renametoClassName = explode(',', $renametoClassName);
					$renamefromClassName = explode(',', $renamefromClassName);
					if(!(is_array($renametoClassName) && is_array($renamefromClassName) && count($renametoClassName) == count($renamefromClassName))){
						_systemError('class rename error! renameto-from count missmatch renameto-count='.count($renametoClassName).' renamefrom-count='.count($renamefromClassName));
					}
					for($renameIndex=0; count($renamefromClassName)>$renameIndex; $renameIndex++){
						$classBuffer = preg_replace('/(class|abstract|interface)\s+?'.trim($renamefromClassName[$renameIndex]).'(\s|\{|\r|\n)/', '\1 '. trim($renametoClassName[$renameIndex]), $classBuffer);
					}
				}
				else{
					$classBuffer = preg_replace('/(class|abstract|interface)\s+?'.trim($renamefromClassName).'/', '\1 '. $renametoClassName, $classBuffer);
				}
			}
			// 定義の動的変更を実行
			if(isset($classBuffer)){
				// PHPの開始タグがあるとコケるので消す
				$classBuffer = preg_replace('/^<\?(php){0,1}(\s|\t)*?(\r\n|\r|\n)/s', '', $classBuffer);
				// PHPの終了タグがあるとコケるので消す
				$classBuffer = preg_replace('/(\r\n|\r|\n)\?>(\r\n|\r|\n){0,1}$/s', '', $classBuffer);
				eval($classBuffer);
				$classCheck = '';
				$matches = NULL;
				if(preg_match('/(class|abstract|interface)\s+?([^\s\t\r\n\{]+)/', $classBuffer, $matches) && is_array($matches) && isset($matches[2]) && strlen($matches[2]) > 0){
					$classCheck = $matches[2];
				}
				// ジェネレート処理
				if(TRUE === $autoGenerateFlag){
					generateClassCache($generatedIncFileName, $classPath, $classBuffer, $classCheck);
				}
				unset($classdef);
				unset($classBuffer);
			}
			// クラス名をマッピングする処理
			if(0 < @strlen($pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->mapto) && 0 < @strlen($pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->mapfrom)){
				$classCheck = '';
				$maptoClassName = $pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->mapto;
				$mapfromClassName = $pkConfXML->{$packageName}->link[$packagePathCnt]->attributes()->mapfrom;
				if(FALSE !== strpos($maptoClassName, ',')){
					$maptoClassName = explode(',', $maptoClassName);
					$mapfromClassName = explode(',', $mapfromClassName);
					if(!(is_array($maptoClassName) && is_array($mapfromClassName) && count($maptoClassName) == count($mapfromClassName))){
						_systemError('class map error! mapto-from count missmatch mapto-count=' . count($maptoClassName) . ' mapfrom-count=' . count($mapfromClassName));
					}
					$mapClass = array();
					for($mapIndex=0;count($maptoClassName)>$mapIndex; $mapIndex++){
						$mapClass[] = 'class ' . $maptoClassName[$mapIndex] . ' extends ' . $mapfromClassName[$mapIndex].'{}';
					}
					$mapClass = implode('', $mapClass);
					$classCheck = ' && !class_exists(\'' . $maptoClassName[0] . '\', FALSE)';
				}
				else{
					$mapClass = 'class ' . $maptoClassName . ' extends ' . $mapfromClassName . '{}';
					$classCheck = ' && !class_exists(\'' . $maptoClassName . '\', FALSE)';
				}
				// マップクラス生成
				eval($mapClass);
				// ジェネレート処理
				if(TRUE !== $fileget && TRUE === $autoGenerateFlag){
					@file_put_contents_e($generatedIncFileName, '<?php' . PHP_EOL . 'if(FALSE === $unlink' . $classCheck . '){ ' . $mapClass . ' }' . PHP_EOL . '?>', FILE_APPEND);
					@chmod($generatedIncFileName, 0777);
				}
				unset($mapClass);
			}
		}
		// 代表クラス名が定義されているかどうか
		// パッケージ名と実際に利用しようとしているクラス名が異なる場合の定義はココを通る
		if(isset($pkConfXML->{$packageName}->class)){
			$className = $pkConfXML->{$packageName}->class;
			// そのパッケージの代表クラスの読み込みが成功しているかどうかをチェック
			if(!class_exists($className, FALSE)){
				if(FALSE === $argClassExistsCalled){
					// クラスが存在しないエラー
					_systemError('not found class ' . $className . ' on ' . $pkConfXML->{$packageName}->link[$packagePathCnt] . '!! Please check default path config.' . PHP_EOL . str_replace(PATH_SEPARATOR, PHP_EOL, get_include_path()));
				}
				return FALSE;
			}
		}
	}
	// 代表クラス名を返して終了
	return (string) $className;
}

/**
 * デフォルト定義されたパッケージ走査に従ってパッケージを探し読み込みをする(内部関数)
 */
function _loadDefaultModule($argHint, $argClassExistsCalled = FALSE, $argPackageName='', $argFileGetContentsEnabled = FALSE){

	if(!function_exists('_loadMatchDefaultNodeModule')){
		/**
		 * ローカル関数:指定されたデフォルトノードの該当のパスからパッケージを探してロードを試みる
		 * ※ただ手続きだと見難いので関数化しただけ
		 */
		function _loadDefaultNodeModule($argNode, $argHint, $argClassExistsCalled = FALSE, $argPackageName='', $argFileGetContentsEnabled = FALSE){
			$loaded = FALSE;
			// パッケージヒント文字列
			$hintPath = str_replace('/', '.', $argHint);
			// 自動ジェネレートフラグの取得
			$autoGenerateFlag = getAutoGenerateEnabled();
			if(TRUE === $autoGenerateFlag){
				$generatedIncFileName = getAutoGeneratedPath().$hintPath.'.generated.inc.php';
			}
			// パッケージ定義の初期化
			$pkConfXMLs = _initFramework(TRUE);
			for($packageCnt = 0; count($pkConfXMLs) > $packageCnt; $packageCnt++){
				$pkConfXML = $pkConfXMLs[$packageCnt]['dom'];
				if(isset($pkConfXML->default) && isset($pkConfXML->default->{$argNode})){
					for($packagePathCnt = 0, $errorCnt = 0; count($pkConfXML->default->{$argNode}) > $packagePathCnt; $packagePathCnt++){
						if(TRUE === $argFileGetContentsEnabled){
							$file = @file_get_contents($pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName.$pkConfXML->default->{$argNode}[$packagePathCnt]->attributes()->suffix, TRUE);
							if(strlen($file) > 0){
								$path = $pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName.$pkConfXML->default->{$argNode}[$packagePathCnt]->attributes()->suffix;
								$loaded = TRUE;
								BREAK 2;
							}
							$file = @file_get_contents($pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName, TRUE);
							if(strlen($file) > 0){
								$path = $pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName;
								$loaded = TRUE;
								BREAK 2;
							}
						}
						else{
							if(FALSE !== @include_once($pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName.$pkConfXML->default->{$argNode}[$packagePathCnt]->attributes()->suffix)){
								$loaded = TRUE;
								// ジェネレート処理
								if(TRUE === $autoGenerateFlag){
									generateIncCache($generatedIncFileName, $pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName.$pkConfXML->default->{$argNode}[$packagePathCnt]->attributes()->suffix);
								}
								BREAK 2;
							}
							if(FALSE !== @include_once($pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName)){
								$loaded = TRUE;
								// ジェネレート処理
								if(TRUE === $autoGenerateFlag){
									generateIncCache($generatedIncFileName, $pkConfXML->default->{$argNode}[$packagePathCnt].'/'.$argPackageName);
								}
								BREAK 2;
							}
						}
					}
				}
			}
			if(isset($file) && isset($path)){
				// 読み込み結果を返して正常終了とする
				return array('classdef' => $file, 'classpath' => $path);
			}
			return $loaded;
		};

		/**
		 * ローカル関数:指定されたデフォルトノードにマッチしたパッケージヒントがマッチしていればそのノードの該当のパスからパッケージを探してロードを試みる
		 * ※ただ手続きだと見難いので関数化しただけ
		 */
		function _loadMatchDefaultNodeModule($argNode, $argHint, $argClassExistsCalled = FALSE, $argPackageName='', $argFileGetContentsEnabled = FALSE){
			$loaded = NULL;
			$matches = NULL;
			if(preg_match('/^' . $argNode . '\.(.+)/', $argPackageName, $matches)){
				$argPackageName = $matches[1];
				$loaded = _loadDefaultNodeModule($argNode, $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
				if(FALSE === $loaded && FALSE === $argClassExistsCalled){
					_systemError('not found ' . $argNode . ' ' . $argPackageName . '!! Please check default path config.' . PHP_EOL . str_replace(PATH_SEPARATOR, PHP_EOL, get_include_path()));
				}
			}
			return $loaded;
		};
	}

	// resがNULLの間は走査が続く
	$res = _loadMatchDefaultNodeModule('controlmain', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	$res = _loadMatchDefaultNodeModule('modelmain', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	$res = _loadMatchDefaultNodeModule('consolemain', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	$res = _loadMatchDefaultNodeModule('abstract', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	$res = _loadMatchDefaultNodeModule('interface', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	$res = _loadMatchDefaultNodeModule('implement', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(NULL !== $res){
		// ※マッチしたのに無かったと言う場合もココを通って異常終了する！
		return $res;
	}
	// ※ここまで来てしまったらdefault定義パスを全走査
	$res = _loadDefaultNodeModule('implement', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(FALSE !== $res){
		// ※無事に見つかって正常終了！
		return $res;
	}
	$res = _loadDefaultNodeModule('link', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(FALSE !== $res){
		// ※無事に見つかって正常終了！
		return $res;
	}
	$res = _loadDefaultNodeModule('abstract', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(FALSE !== $res){
		// ※無事に見つかって正常終了！
		return $res;
	}
	$res = _loadDefaultNodeModule('interface', $argHint, $argClassExistsCalled, $argPackageName, $argFileGetContentsEnabled);
	if(FALSE !== $res){
		// ※無事に見つかって正常終了！
		return $res;
	}

	// ※それでもなければインクルードパスを信じてみる！！
	if(TRUE === $argFileGetContentsEnabled){
		$file = @file_get_contents($argPackageName, TRUE);
		if(strlen($file) == 0){
			// 拡張子足して試してみる
			$file = @file_get_contents($argPackageName.'.php', TRUE);
			if(strlen($file) == 0){
				// 何をやってもDefaultパッケージからは見つけられなかった
				if(FALSE === $argClassExistsCalled){
					_systemError('not found package ' . $argPackageName . '!! Please check default path config.' . PHP_EOL . str_replace(PATH_SEPARATOR, PHP_EOL, get_include_path()));
				}
				return FALSE;
			}
			// パッケージ名を決定したものに変更
			$argPackageName = $argPackageName.'.php';
		}
		$path = $argPackageName;
	}
	else{
		if(FALSE === @include_once($argPackageName)){
			// 拡張子足して試してみる
			if(FALSE === @include_once($argPackageName.'.php')){
				if(FALSE === $argClassExistsCalled){
					// 何をやってもDefaultパッケージからは見つけられなかった
					_systemError('not found package ' . $argPackageName . '!! Please check default path config.' . PHP_EOL . str_replace(PATH_SEPARATOR, PHP_EOL, get_include_path()));
				}
				return FALSE;
			}
			// パッケージ名を決定したものに変更
			$argPackageName = $argPackageName.'.php';
		}
		// インクルードに成功したので、ジェネレート処理
		if(TRUE === $autoGenerateFlag){
			generateIncCache($generatedIncFileName, $argPackageName);
		}
	}

	if(isset($file) && isset($path)){
		// 読み込み結果を返して正常終了とする
		return array('classdef' => $file, 'classpath' => $path);
	}
	return TRUE;
}


/**
 * configの読み込みとconfigureクラスの定義を実行する
 */
function loadConfig($argConfigPath){

	// 自動ジェネレートフラグの取得
	$autoGenerateFlag = getAutoGenerateEnabled();

	static $autoMigrateFlag = NULL;
	static $localFlag = NULL;
	static $devFlag = NULL;
	static $testFlag = NULL;
	static $stagingFlag = NULL;
	static $debugFlag = NULL;
	static $errorReportFlag = NULL;
	static $regenerateFlag = NULL;

	if(NULL === $errorReportFlag){
		$corefilename = corefilename();
		// 各種フラグメントの取得
		$autoMigrateEnabled = dirname(dirname(__FILE__)).'/.automigrate';
		if(defined($corefilename . '_AUTO_MIGRATE_ENABLED')){
			$autoMigrateEnabled = constant($corefilename . '_AUTO_MIGRATE_ENABLED');
		}
		$stageLocalEnabled = dirname(dirname(__FILE__)).'/.local';
		if(defined($corefilename . '_STAGE_LOCAL_ENABLED')){
			$stageLocalEnabled = constant($corefilename . '_STAGE_LOCAL_ENABLED');
		}
		$stageDevEnabled = dirname(dirname(__FILE__)).'/.dev';
		if(defined($corefilename . '_STAGE_DEV_ENABLED')){
			$stageDevEnabled = constant($corefilename . '_STAGE_DEV_ENABLED');
		}
		$stageTestEnabled = dirname(dirname(__FILE__)).'/.test';
		if(defined($corefilename . '_STAGE_TEST_ENABLED')){
			$stageTestEnabled = constant($corefilename . '_STAGE_TEST_ENABLED');
		}
		$stageStagingEnabled = dirname(dirname(__FILE__)).'/.staging';
		if(defined($corefilename . '_STAGE_STAGING_ENABLED')){
			$stageStagingEnabled = constant($corefilename . '_STAGE_STAGING_ENABLED');
		}
		$debugModeEnabled = dirname(dirname(__FILE__)).'/.debug';
		if(defined($corefilename . '_DEBUG_MODE_ENABLED')){
			$debugModeEnabled = constant($corefilename . '_DEBUG_MODE_ENABLED');
		}
		$errorReportEnabled = dirname(dirname(__FILE__)).'/.error_report';
		if(defined($corefilename . '_ERROR_REPORT_ENABLED')){
			$errorReportEnabled = constant($corefilename . '_ERROR_REPORT_ENABLED');
		}
		// 自動マイグレート設定フラグのセット
		$autoMigrateFlag = file_exists($autoMigrateEnabled);
		// ローカル環境フラグのセット
		$localFlag = file_exists($stageLocalEnabled);
		// 開発環境フラグのセット
		$devFlag = file_exists($stageDevEnabled);
		// テスト環境(テスト用凍結環境)フラグのセット
		$testFlag = file_exists($stageTestEnabled);
		// ステージング環境フラグのセット
		$stagingFlag = file_exists($stageStagingEnabled);
		// デバッグモードフラグのセット
		$debugFlag = file_exists($debugModeEnabled);
		// エラーレポートフラグのセット
		$errorReportFlag = file_exists($errorReportEnabled);
	}

	if(TRUE === $autoGenerateFlag){
		if(is_file($argConfigPath)){
			// フラグメントキャッシュの更新が有れば、コンフィグファイルを強制再読み込みする為のチェック
			if(NULL === $regenerateFlag){
				$flagcacheFileName = dirname(dirname(__FILE__)).'/autogenerate/flagcache.php';
				if(file_exists($flagcacheFileName)){
					require_once $flagcacheFileName;
					if(!isset($flagchaces['autoMigrateFlag']) || $autoMigrateFlag != $flagchaces['autoMigrateFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['localFlag']) || $localFlag != $flagchaces['localFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['devFlag']) || $devFlag != $flagchaces['devFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['testFlag']) || $testFlag != $flagchaces['testFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['stagingFlag']) || $stagingFlag != $flagchaces['stagingFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['debugFlag']) || $debugFlag != $flagchaces['debugFlag']){
						$regenerateFlag = TRUE;
					}
					if(!isset($flagchaces['errorReportFlag']) || $errorReportFlag != $flagchaces['errorReportFlag']){
						$regenerateFlag = TRUE;
					}
				}
				else{
					$regenerateFlag = TRUE;
				}
				if(TRUE === $regenerateFlag){
					$flagchaceBody = '$flagchaces = array(\'autoMigrateFlag\'=>' . (int)$autoMigrateFlag . ', \'localFlag\'=>' . (int)$localFlag . ', \'devFlag\'=>' . (int)$devFlag . ', \'testFlag\'=>' . (int)$testFlag . ', \'stagingFlag\'=>' . (int)$stagingFlag . ', \'debugFlag\'=>' . (int)$debugFlag . ', \'errorReportFlag\'=>' . (int)$errorReportFlag . ');';
					// フラグメントキャッシュを更新
					file_put_contents($flagcacheFileName, '<?php' . PHP_EOL . $flagchaceBody . PHP_EOL . '?>');
					@chmod($flagcacheFileName,0777);
				}
			}
			if(TRUE !== $regenerateFlag){
				$configFileName = basename($argConfigPath);
				$generatedConfigFileName = getAutoGeneratedPath().$configFileName.'.generated.php';
				if(file_exists($generatedConfigFileName) && filemtime($generatedConfigFileName) >= filemtime($argConfigPath)){
					// 静的ファイル化されたコンフィグクラスファイルを読み込んで終了
					// fatal errorがいいのでrequireする
					require_once $generatedConfigFileName;
					return TRUE;
				}
			}
		}
	}

	if(!is_file($argConfigPath)){
		return FALSE;
	}

	// configureの初期化
	$configs = array();
	$configure = simplexml_load_file($argConfigPath, NULL, LIBXML_NOCDATA);

	// 環境フラグをセット
	if(!class_exists('Configure', FALSE)){
		$configure->addChild('AUTO_GENERATE_FLAG', $autoGenerateFlag);
		$configure->addChild('AUTO_MIGRATE_FLAG', $autoMigrateFlag);
		$configure->addChild('LOCAL_FLAG', $localFlag);
		$configure->addChild('DEV_FLAG', $devFlag);
		$configure->addChild('TEST_FLAG', $testFlag);
		$configure->addChild('STAGING_FLAG', $stagingFlag);
		$configure->addChild('DEBUG_FLAG', $debugFlag);
		$configure->addChild('ERROR_REPORT_FLAG', $errorReportFlag);
	}

	foreach(get_object_vars($configure) as $key => $val){
		if('comment' != $key){
			if(count($configure->{$key}->children()) > 0){
				if(!isset($configs[$key.'Configure'])){
					$configs[$key.'Configure'] = '';
				}
				foreach(get_object_vars($val) as $key2 => $val2){
					$evalFlag = FALSE;
					if(count($val2) > 1){
						$skip = TRUE;
						for($attrCnt=0;count($val2)>$attrCnt;$attrCnt++){
							if(isset($configure->{$key}->{$key2}[$attrCnt]->attributes()->stage)){
								$stage = $configure->{$key}->{$key2}[$attrCnt]->attributes()->stage;
								if('local' == $stage && TRUE === $localFlag){
									$skip = FALSE;
									BREAK;
								}
								elseif('dev' == $stage && TRUE === $devFlag){
									$skip = FALSE;
									BREAK;
								}
								elseif('test' == $stage && TRUE === $testFlag){
									$skip = FALSE;
									BREAK;
								}
								elseif('staging' == $stage && TRUE === $stagingFlag){
									$skip = FALSE;
									BREAK;
								}
							}
							else{
								$defAttrCnt = $attrCnt;
							}
						}
						if(TRUE === $skip){
							$attrCnt = $defAttrCnt;
						}
						$val2 = $val2[$attrCnt];
						if(isset($configure->{$key}->{$key2}[$attrCnt]->attributes()->code)){
							$evalFlag = TRUE;
						}
					}
					elseif(isset($configure->{$key}->{$key2}) && isset($configure->{$key}->{$key2}->attributes()->code)){
						$evalFlag = TRUE;
					}
					$val2 = trim($val2);
					$matches = NULL;
					if(preg_match_all('/\%(.+)\%/',$val2,$matches) > 0){
						for($matchCnt=0; count($matches[0]) > $matchCnt; $matchCnt++){
							$matchKey = $matches[0][$matchCnt];
							$matchStr = $matches[1][$matchCnt];
							$val2 = substr_replace($val2,$val->{$matchStr},strpos($val2,$matchKey),strlen($matchKey));
						}
					}
					if(TRUE === $evalFlag){
						if(FALSE !== strpos($val2, '__FILE__')){
							$val2 = str_replace('__FILE__', '\'' . realpath($argConfigPath) .'\'', $val2);
						}
						@eval('$val2 = '.$val2.';');
						$configure->{$key}->{$key2} = $val2;
						$configs[$key.'Configure'] .= "\t".'const '.$key2.' = \''.$val2.'\';'.PHP_EOL;
					}
					else{
						if(strlen($val2) == 0){
							$configs[$key.'Configure'] .= "\t".'const '.$key2.' = \'\';'.PHP_EOL;
						}elseif('TRUE' == strtoupper($val2) || 'FALSE' == strtoupper($val2) || 'NULL' == strtoupper($val2) || is_numeric($val2)){
							$configs[$key.'Configure'] .= "\t".'const '.$key2.' = '.$val2.';'.PHP_EOL;
						}else{
							$configs[$key.'Configure'] .= "\t".'const '.$key2.' = \''.addslashes($val2).'\';'.PHP_EOL;
						}
					}
				}
			}
			else{
				$evalFlag = FALSE;
				if(count($val) > 1){
					$skip = TRUE;
					for($attrCnt=0;count($val)>$attrCnt;$attrCnt++){
						if(isset($configure->{$key}[$attrCnt]->attributes()->stage)){
							$stage = $configure->{$key}[$attrCnt]->attributes()->stage;
							if('local' == $stage && TRUE === $localFlag){
								$skip = FALSE;
								BREAK;
							}
							elseif('dev' == $stage && TRUE === $devFlag){
								$skip = FALSE;
								BREAK;
							}
							elseif('test' == $stage && TRUE === $testFlag){
								$skip = FALSE;
								BREAK;
							}
							elseif('staging' == $stage && TRUE === $stagingFlag){
								$skip = FALSE;
								BREAK;
							}
						}
						else{
							$defAttr = $attrCnt;
						}
					}
					if(TRUE === $skip){
						$attrCnt = $defAttr;
					}
					$val = $val[$attrCnt];
					if(isset($configure->{$key}[$attrCnt]->attributes()->code)){
						$evalFlag = TRUE;
					}
				}
				elseif(isset($configure->{$key}->attributes()->code)){
					$evalFlag = TRUE;
				}
				$val = trim($val);
				$matches = NULL;
				if(preg_match_all('/\%(.+)\%/',$val,$matches) > 0){
					for($matchCnt=0; count($matches[0]) > $matchCnt; $matchCnt++){
						$matchKey = $matches[0][$matchCnt];
						$matchStr = $matches[1][$matchCnt];
						$val = substr_replace($val,$configure->{$matchStr},strpos($val,$matchKey),strlen($matchKey));
					}
				}

				if(TRUE === $evalFlag){
					if(FALSE !== strpos($val, '__FILE__')){
						$val = str_replace('__FILE__', '\'' . realpath($argConfigPath) .'\'', $val);
					}
					eval('$val = '.$val.';');
					if(!isset($configs['Configure'])){
						$configs['Configure'] = '';
					}
					//define($key,$val);
					$configs['Configure'] .= "\t".'const '.$key.' = \''.$val.'\';'.PHP_EOL;
				}
				else{
					if(!isset($configs['Configure'])){
						$configs['Configure'] = '';
					}
					if(strlen($val) == 0){
						//define($key,'');
						$configs['Configure'] .= "\t".'const '.$key.' = \'\';'.PHP_EOL;
					}
					elseif('TRUE' == strtoupper($val) || 'FALSE' == strtoupper($val) || 'NULL' == strtoupper($val) || is_numeric($val)){
						//define($key,$val);
						$configs['Configure'] .= "\t".'const '.$key.' = '.$val.';'.PHP_EOL;
					}
					else{
						// XXX ココ危険！！！addslashesしないと行けないシチュエーションが出てくるかも
						//define($key,$val);
						$configs['Configure'] .= "\t".'const '.$key.' = \''.addslashes($val).'\';'.PHP_EOL;
					}
				}
			}
		}
	}

	static $baseConfigureClassDefine = NULL;
	if(NULL === $baseConfigureClassDefine){



		/*------------------------------ Configureクラス定義のスケルトン ココから ------------------------------*/

		$baseConfigureClassDefine = <<<_CLASSDEF_
class %class% {

	%consts%

	private static function _search(\$argVal,\$argKey,\$argHints){
		if(preg_match('/'.\$argHints['hint'].'/',\$argKey)){
			\$argHints['data'][\$argKey] = \$argVal;
		}
	}

	public static function constant(\$argHint,\$argSearchFlag = FALSE){
		static \$myConsts = NULL;
		if(FALSE !== \$argSearchFlag){
			if(NULL === \$myConsts){
				\$ref = new ReflectionClass(__CLASS__);
				\$myConsts = \$ref->getConstants();
			}
			\$tmpArr = array();
			foreach(\$myConsts as \$key => \$val){
				if(preg_match('/'.\$argHint.'/',\$key)){
					\$tmpArr[\$key] = \$val;
				}
			}
			if(count(\$tmpArr)>0){
				return \$tmpArr;
			}
		}
		elseif(TRUE === defined('self::'.\$argHint)){
			return constant('self::'.\$argHint);
		}
		return NULL;
	}
}

\$paths = %class%::constant(".+_PATH$", TRUE);
foreach(\$paths as \$key => \$val){
	set_include_path(get_include_path().PATH_SEPARATOR.\$val);
}

_CLASSDEF_;

		/*------------------------------ Configureクラス定義のスケルトン ココまで ------------------------------*/



	}

	// Configureクラスを宣言する
	$configGeneratClassDefine = NULL;
	foreach($configs as $key => $val){
		$configClassDefine = $baseConfigureClassDefine;
		if('Configure' !== $key){
			$configClassDefine .= "\r\n/*requireに成功しているので、initFrameworkでコンフィグを追加する*/\r\n_initFramework('%class%');";
		}
		$configClassDefine = str_replace('%class%',ucwords($key),$configClassDefine);
		$configClassDefine = str_replace('%consts%',substr($val,1),$configClassDefine);
		if(TRUE === $autoGenerateFlag){
			$configGeneratClassDefine .= $configClassDefine;
		}
		else{
			eval($configClassDefine);
		}
	}

	// ジェネレート処理
	if(TRUE === $autoGenerateFlag){
		$configFileName = basename($argConfigPath);
		$generatedConfigFileName = getAutoGeneratedPath().$configFileName.'.generated.php';
		// タブ文字削除
		$configGeneratClassDefine = str_replace("\t", '', $configGeneratClassDefine);
		// 改行文字削除
		$configGeneratClassDefine = str_replace(array("\r","\n"), '', $configGeneratClassDefine);
		file_put_contents($generatedConfigFileName, '<?php' . PHP_EOL . $configGeneratClassDefine . PHP_EOL . '?>');
		@chmod($generatedConfigFileName,0777);
		// 静的ファイル化されたコンフィグクラスファイルを読み込んで終了
		require_once $generatedConfigFileName;
	}

	// インクルードパスの追加処理
	foreach($configs as $key => $val){
		$ConfigClassName = ucwords($key);
		$paths = $ConfigClassName::constant(".+_PATH$", TRUE);
		foreach($paths as $key => $val){
			set_include_path(get_include_path().PATH_SEPARATOR.$val);
		}
	}

	return TRUE;
}

/**
 * フレームワークの初期化処理(内部関数)
 * @param mixed TRUEの時は、読み込み済みのパッケージ情報を返す stringの時はConfigureクラス名としてConfigureクラスに対してのinitを処理する
 */
function _initFramework($argment = NULL){

	// 読み込み済みのパッケージ定義格納用
	static $pkgConfXML = NULL;
	// 処理済みのConfigureクラス名格納用
	static $argmentKeys = NULL;

	if(TRUE === $argment && NULL !== $pkgConfXML){
		// 敢えて直ぐ返す
		return $pkgConfXML;
	}

	if(!function_exists('_loadPackage')){
		/**
		 * ローカル関数:指定されたパッケージのロード処理
		 * ※ただ手続きだと見難いので関数化しただけ
		 */
		function _loadPackage($pkgConfXMLPath, &$pkgConfXML){
			if(is_array($pkgConfXMLPath)){
				if(count($pkgConfXMLPath) > 0) {
					// 再帰処理
					foreach($pkgConfXMLPath as $key => $path){
						_loadPackage($path, $pkgConfXML);
					}
				}
			}
			else{
				if(file_exists($pkgConfXMLPath)){
					if(NULL === $pkgConfXML){
						// 配列に初期化
						$pkgConfXML = array();
					}
					// XXX 新しいパッケージは常に配列の先頭に！
					array_unshift($pkgConfXML, array('time' => filemtime($pkgConfXMLPath), 'dom' => simplexml_load_file($pkgConfXMLPath, NULL, LIBXML_NOCDATA)));
					// defaulのauto節を処理する
					if(count($pkgConfXML[0]['dom']->default->auto) > 0){
						foreach($pkgConfXML[0]['dom']->default->auto->children() as $autoLoadModule){
							loadModule($autoLoadModule);
						}
					}
				}
			}
		};
	}

	// デフォルトのフレームワークのpackageXMLを探して全て読み込む
	if(NULL === $pkgConfXML){
		// 「package.xml」と言うファイルがこのファイルと同じ階層にあったら読み込む
		_loadPackage(dirname(__FILE__).'/package.xml', $pkgConfXML);
		// このファイルと同じ名前で拡張子が「.package.xml」のファイルがこのファイルと同じ階層にあったら読み込む
		_loadPackage(dirname(__FILE__).'/' . strtoupper(substr(basename(__FILE__), 0, strpos(basename(__FILE__), '.'))) . '.package.xml', $pkgConfXML);
		// 「.*PACKAGE_CONFIG_XML_PATH.*」に該当するConfigureクラス定数定義されたパスのファイルがあったら全て読み込む
		_loadPackage(Configure::constant('.*PACKAGE_CONFIG_XML_PATH.*', TRUE), $pkgConfXML);
		// Configureクラス定義のパッケージは全て読み込み済みとする
		$argmentKeys[] = 'Configure';
		// 「.*PACKAGE_CONFIG_XML_PATH.*」に該当する通常定数定義されたパスのファイルがあったら全て読み込む
		_loadPackage(constants('.*PACKAGE_CONFIG_XML_PATH.*',TRUE), $pkgConfXML);
		// デフォルトでパッケージが一個も見つからなかったらエラー
		if(NULL === $pkgConfXML){
			_systemError('not found package.xml  !! Please check default path config.' . PHP_EOL . str_replace(PATH_SEPARATOR, PHP_EOL, get_include_path()));
		}
	}

	// 渡されたConfigureクラス名のConfigureクラスをinit処理して$pkgConfXMLのリフレッシュする
	if(NULL !== $argment && TRUE !== $argment && is_string($argment)){
		// 処理済みでは無いかどうか
		// 更に、クラスが存在するかどうか
		if(!in_array($argment, $argmentKeys) && class_exists($argment, FALSE)){
			// 「.*PACKAGE_CONFIG_XML_PATH.*」に該当するConfigureクラス定数定義されたパスのファイルがあったら全て読み込む
			_loadPackage($argment::constant('.*PACKAGE_CONFIG_XML_PATH.*', TRUE), $pkgConfXML);
			// 2度処理しないように追加しておく
			$argmentKeys[] = $argment;
		}
	}

	if(TRUE === $argment){
		// TRUEの時は処理後のパッケージ定義を全て返す
		return $pkgConfXML;
	}
}

/**
 * 外部からのフレームワークの明示的初期化処理
 */
eval('function init' . $corefilename . '($argment = NULL){ return _initFramework($argment); }');

/**
 * フレームワーク内のエラー処理
*/
function _systemError($argMsg){
	$corefilename = strtoupper(substr(basename(__FILE__), 0, strpos(basename(__FILE__), '.')));
	// ココを通るのは相当なイレギュラー
	if(defined($corefilename . '_ERROR_FINALIS')){
		eval(constant($corefilename . '_ERROR_FINALIS').'();');
	}
	else{
		header('HTTP/1.0 500 Internal Server Error');
		echo '<h1>Internal Server Error</h1>'.PHP_EOL;
		echo '<br/>'.PHP_EOL;
		echo 'Please check exception\'s log'.PHP_EOL;
	}
	// 開発状態のみエラー表示をする
	if(isTest()) {
		echo $argMsg;
		// PHPUnitTestではdebugtraceを取らない・・・(traceが長すぎてパンクする・・・)
		if(!class_exists('PHPUnit_Framework_TestCase', FALSE)){
			echo "\n<br>\n" . str_replace(array(" ", "\n"), array("&nbsp;", "\n<br>\n"), var_export(debug_backtrace(), TRUE));
		}
	}
	// PHPUnitTestではdebugtraceを取らない・・・(traceが長すぎてパンクする・・・)
	if(!class_exists('PHPUnit_Framework_TestCase', FALSE)){
		logging($argMsg.PATH_SEPARATOR.var_export(debug_backtrace(),TRUE),'exception');
	}
	exit();
}

/**
 * 外部からのフレームワークの明示的エラー処理
 */
eval('function error' . $corefilename . '($argMsg){ _systemError($argMsg); }');

/**
 * フレームワークの終了処理
 * ob_startを仕掛けたプログラムの終了時にコールされる
 * @param バッファストリング
*/
function _callbackAndFinalize($argBuffer){
	// return ってすると出力されるのよ。
	return $argBuffer;
}

/**
 * 単純なsessionIDのストア
 */
function _sessionIDStroe($argAction,$argSID = NULL){
	static $sessionID = NULL;
	if('get' === strtolower($argAction)){
		if(NULL == $sessionID){
			if(session_status()!=PHP_SESSION_ACTIVE)session_start();
			$sessionID = session_id();
		}
		return $sessionID;
	}
	elseif('set' === strtolower($argAction)){
		$sessionID = $argSID;
	}
}

/**
 * sessionIDのアクセサ
 */
function setSessionID($argSessionID){
	_sessionIDStroe('set',$argSessionID);
}

/**
 * sessionIDのアクセサ
 */
function getSessionID(){
	return _sessionIDStroe('get');
}

/**
 * 単純なUIDのストア
 */
function _uniqueuserIDStroe($argAction,$argUID = NULL){
	static $UID = NULL;
	if('get' === strtolower($argAction)){
		if(NULL == $UID){
			$UID = uniqid();
		}
		return $UID;
	}
	elseif('set' === strtolower($argAction)){
		$UID = $argUID;
	}
}

/**
 * UIDのセットアクセサ
 */
function setUID($argUID){
	_uniqueuserIDStroe('set',$argUID);
}

/**
 * UIDのゲットアクセサ
 */
function getUID(){
	return _uniqueuserIDStroe('get');
}

/**
 * pathを一気に上まで駆け上がる！
 */
function path($argFilePath, $argDepth = 1){
	for($pathUpcnt=0; $argDepth > $pathUpcnt; $pathUpcnt++){
		$argFilePath = dirname($argFilePath);
	}
	return $argFilePath;
}

define('FILE_PREPEND', 'FILE_PREPEND');
/**
 * file_put_contentsのフラグ指定を拡張
 * $argMode=FILE_APPEND=a+
 * $argMode=FOPENMODE(rとかt+とか)
*/
function file_put_contents_e($argFilePath, $argData, $argMode=0){
	$mode = $argMode;
	if(FILE_APPEND === $argMode){
		$mode = 'a+';
	}
	if(FILE_PREPEND === $argMode){
		$mode = 'w';
		$argData .= file_get_contents($argFilePath);
	}
	$handle = @fopen($argFilePath, $mode);
	if($handle){
		fwrite($handle, $argData);
		fclose($handle);
	}
	else{
		return FALSE;
	}
	return TRUE;
}

/**
 * logging出力
 */
function logging($arglog, $argLogName = NULL, $argConsolEchoFlag = FALSE){

	static $pdate = NULL;
	static $phour = NULL;
	static $loggingLineNum = 1;

	$logpath = dirname(dirname(dirname(__FILE__))).'/log/';
	if(class_exists('Configure', FALSE) && NULL !== constant('Configure::LOG_PATH')){
		$logpath = Configure::LOG_PATH;
	}

	if(class_exists('Configure', FALSE) && NULL !== constant('Configure::DEBUG_FLAG')){
		$debugFlag = Configure::DEBUG_FLAG;
	}

	// XXX ログローテートの実行

	if(NULL === $argLogName){
		$argLogName = 'process';
	}

	if(NULL === $pdate){
		$deftimezone = @date_default_timezone_get();
		date_default_timezone_set('Asia/Tokyo');
		$dateins = new DateTime();
		$pdate = $dateins->format('Y-m-d H:i:s') . ' [UDate:'. microtime(TRUE).']';
		$phour = $dateins->format('H');
		date_default_timezone_set($deftimezone);
	}
	if(is_array($arglog) || is_object($arglog)){
		$arglog = var_export($arglog, TRUE);
	}
	if(isset($_SERVER['REQUEST_URI'])){
		$arglog = '[URI:'.$_SERVER['REQUEST_URI'].']'.$arglog;
	}
	$logstr = $pdate.'[logging'.$loggingLineNum.'][SID:'.getSessionID().'][UID:'.getUID().']'.$arglog;

	// 改行コードは\rだけにして、一行で表現出来るようにする
	$logstr = str_replace("\r",'[EOL]',$logstr);
	$logstr = str_replace("\n",'[EOL]',$logstr);
	if('process' !== $argLogName){
		// process_logは常に出す
		if(!is_file($logpath.'process_log')){
			@touch($logpath.'process_log');
			@chmod($logpath.'process_log', 0666);
		}
		if(!is_file($logpath.'process_'.$phour.'.log')){
			@touch($logpath.'process_'.$phour.'.log');
			@chmod($logpath.'process_'.$phour.'.log', 0666);
		}
		@file_put_contents($logpath.'process_log', $logstr.PHP_EOL, FILE_APPEND);
		@file_put_contents($logpath.'process_'.$phour.'.log', $logstr.PHP_EOL, FILE_APPEND);
	}
	if(!is_file($logpath.$argLogName.'_log')){
		@touch($logpath.$argLogName.'_log');
		@chmod($logpath.$argLogName.'_log', 0666);
	}
	if(!is_file($logpath.$argLogName.'_'.$phour.'.log')){
		@touch($logpath.$argLogName.'_'.$phour.'.log');
		@chmod($logpath.$argLogName.'_'.$phour.'.log', 0666);
	}
	@file_put_contents($logpath.$argLogName.'_log', $logstr.PHP_EOL, FILE_APPEND);
	@file_put_contents($logpath.$argLogName.'_'.$phour.'.log', $logstr.PHP_EOL, FILE_APPEND);

	// $debugFlagが有効だったらhttpHeaderにログを出しちゃう
	if(isset($debugFlag) && TRUE == $debugFlag && isset($_SERVER['REQUEST_URI']) && 'debug' != $argLogName){
		debug($arglog);
	}

	// XXX consolは画面に出力
	if(TRUE === $argConsolEchoFlag && isset($debugFlag) && TRUE == $debugFlag && !isset($_SERVER['REQUEST_URI'])){
		echo $logstr.PHP_EOL;
	}

	$loggingLineNum++;
}

/**
 * debugログ出力
 */
function debug($arglog){
	logging($arglog, 'debug',TRUE);
}

/**
 * 定数を正規表現で検索可能にする
 */
function constants($argKey, $argSearchFlag = FALSE){
	if(FALSE !== $argSearchFlag){
		$datas = array();
		foreach(get_defined_constants() as $constKey => $val){
			if(preg_match('/'.$argKey.'/',$constKey)){
				$datas[$constKey] = $val;
			}
		}
		if(count($datas)>0){
			return $datas;
		}
	}
	elseif(TRUE === defined($argKey)){
		return constant($argKey);
	}
	return NULL;
}

/**
 * 実行環境チェック
 */
function isTest($argStagingEnabled=FALSE){
	if((defined('Configure::LOCAL_FLAG') && TRUE == Configure::LOCAL_FLAG) || (defined('Configure::DEV_FLAG') && TRUE == Configure::DEV_FLAG) || (defined('Configure::TEST_FLAG') && TRUE == Configure::TEST_FLAG)) {
		if(FALSE === $argStagingEnabled){
			return TRUE;
		}
		elseif(defined('Configure::STAGING_FLAG') && TRUE == Configure::STAGING_FLAG){
			return TRUE;
		}
	}
	return FALSE;
}

/**
 * 現在設定されている自動最適化キャッシュ生成フラグを返す
 */
function getAutoGenerateEnabled(){
	static $autoGenerateEnabled = NULL;
	if(NULL === $autoGenerateEnabled){
		$corefilename = corefilename();
		$autoGenerateEnabledFilepath = dirname(dirname(__FILE__)).'/.autogenerate';
		if(defined($corefilename . '_AUTO_GENERATE_ENABLED')){
			$autoGenerateEnabledFilepath = constant($corefilename . '_AUTO_GENERATE_ENABLED');
		}
		// 自動ジェネレートフラグのセット
		$autoGenerateEnabled = file_exists($autoGenerateEnabledFilepath);
	}
	return $autoGenerateEnabled;
}

/**
 * 現在設定されている自動最適化キャッシュファイル保存先パス情報を返す
 */
function getAutoGeneratedPath(){
	static $generatedPath = NULL;
	if(NULL === $generatedPath){
		$generatedPath = dirname(dirname(__FILE__)).'/autogenerate/';
		if(FALSE !== defined('PROJECT_NAME')){
			// 併設されている事を前提とする！
			$tmpGeneratedPath = dirname(dirname(dirname(__FILE__))).'/'.PROJECT_NAME.'/autogenerate';
			if(TRUE === is_dir($tmpGeneratedPath)){
				// パスとして認める
				$generatedPath = $tmpGeneratedPath.'/';
			}
		}
	}
	return $generatedPath;
}

/**
 * ジェネレートチェックと自動読み込みを解決する
 */
function resolveUnlinkAutoGeneratedFile($generatedIncFileName){
	$unlink=TRUE;
	if(is_file($generatedIncFileName)){
		if(filemtime($generatedIncFileName) >= filemtime(__FILE__)){
			// フレームワークコアの変更が見当たらない場合は、コンフィグと比較
			$pkConfXMLs = _initFramework(TRUE);
			for($pkConfXMLCnt = 0, $timecheckNum = 0; count($pkConfXMLs) > $pkConfXMLCnt; $pkConfXMLCnt++){
				// XXX 時間チェック(タイムゾーン変えてもちゃんと動く？？)
				if(filemtime($generatedIncFileName) >= $pkConfXMLs[$pkConfXMLCnt]['time']){
					$timecheckNum++;
				}
			}
			if($timecheckNum === $pkConfXMLCnt){
				$unlink=FALSE;
				// 静的ファイル化されたrequire群ファイルを読み込んで終了
				// fatal errorがいいのでrequireする
				require_once $generatedIncFileName;
			}
		}
		if(FALSE !== $unlink){
			// ここまで来たら再ジェネレートが走るのでジェネレート済みの古いファイルを削除しておく
			@file_put_contents($generatedIncFileName, '');
			@unlink($generatedIncFileName);
		}
	}
	return $unlink;
}

/**
 * オートジェネレートされるファイルにデフォルトで書き込む処理のベースを文字列で返す(内部関数)
 */
function _getAutoGenerateIncPHPMainBase(){
	static $autoGenerateIncPHPMainBase = NULL;
	if(NULL === $autoGenerateIncPHPMainBase){
		// 1行で返す
		$autoGenerateIncPHPMainBase = "";
		$autoGenerateIncPHPMainBase .= PHP_EOL;
		$autoGenerateIncPHPMainBase .= FILE_CHECK_GENERIC_FUNCTIONS;
		$autoGenerateIncPHPMainBase .= PHP_EOL;
		$autoGenerateIncPHPMainBase .= '$linkFilePath=\'%s\'; ';
		$autoGenerateIncPHPMainBase .= 'if(!isset($unlink)){ $unlink=FALSE; }; ';
		$autoGenerateIncPHPMainBase .= 'if(!(FALSE === $unlink && FALSE !== @file_exists_ip($linkFilePath) && (int)filemtime(__FILE__) >= (int)filemtime_ip($linkFilePath))){ $unlink=TRUE; }; ';
		$autoGenerateIncPHPMainBase .= PHP_EOL;
	}
	return $autoGenerateIncPHPMainBase;
}

/**
 * インクルードキャッシュのジェネレート
 */
function generateIncCache($argGeneratedPath, $argIncludePath){
	// 先ず先頭に条件文を追加
	@file_put_contents_e($argGeneratedPath, '<?php' . sprintf(_getAutoGenerateIncPHPMainBase(), $argIncludePath) . '?>', FILE_PREPEND);
	// ファイルの終端に処理を追加
	@file_put_contents_e($argGeneratedPath, '<?php if(FALSE === $unlink){ @include_once(\'' . $argIncludePath . '\'); } ?>', FILE_APPEND);
	@chmod($argGeneratedPath, 0777);
}

/**
 * クラス自動生成のキャッシュ
 */
function generateClassCache($argGeneratedPath, $argIncludePath, $argClassBuffer, $argClassName=''){
	$classCheck = $argClassName;
	if('' !== $argClassName){
		$classCheck = ' && !class_exists(\'' . $argClassName . '\', FALSE)';
	}
	// 先ず先頭に条件文を追加
	@file_put_contents_e($argGeneratedPath, '<?php' . sprintf(_getAutoGenerateIncPHPMainBase(), $argIncludePath) . '?>', FILE_PREPEND);
	// ファイルの終端に処理を追加
	@file_put_contents_e($argGeneratedPath, '<?php' . PHP_EOL . 'if(FALSE === $unlink' . $classCheck . '){ ' . PHP_EOL . $argClassBuffer . PHP_EOL . '}' . PHP_EOL . '?>', FILE_APPEND);
	@chmod($argGeneratedPath, 0777);
}

/**
 * 現在設定されている自動最適化キャッシュ生成フラグを返す
 */
function getAutoMigrationEnabled(){
	static $autoMigrationEnabled = NULL;
	if(NULL === $autoMigrationEnabled){
		if(NULL !== constant('PROJECT_NAME')){
			// 併設されている事を前提とする！
			$autoMigrationEnabledFilepath = dirname(dirname(dirname(__FILE__))).'/'.PROJECT_NAME.'/.automigration';
		}
		else{
			$corefilename = corefilename();
			$autoMigrationEnabledFilepath = dirname(dirname(__FILE__)).'/.automigration';
			if(defined($corefilename . '_AUTO_MIGRATION_ENABLED')){
				$autoMigrationEnabledFilepath = constant($corefilename . '_AUTO_MIGRATION_ENABLED');
			}
		}
		// 自動マイグレーションフラグのセット
		$autoMigrationEnabled = file_exists($autoMigrationEnabledFilepath);
	}
	return $autoMigrationEnabled;
}

/**
 * 現在設定されている自動最適化キャッシュファイル保存先パス情報を返す
 */
function getAutoMigrationPath(){
	static $migrationPath = NULL;
	if(NULL === $migrationPath){
		$migrationPath = dirname(dirname(__FILE__)).'/automigration/';
		if(NULL !== constant('PROJECT_NAME')){
			// 併設されている事を前提とする！
			$tmpMigrationPath = dirname(dirname(dirname(__FILE__))).'/'.PROJECT_NAME.'/automigration';
			if(TRUE === is_dir($tmpMigrationPath)){
				// パスとして認める
				$migrationPath = $tmpMigrationPath.'/';
			}
		}
	}
	return $migrationPath;
}

/*------------------------------ 根幹関数定義 ココから ------------------------------*/



/*------------------------------ 以下手続き型処理 ココから ------------------------------*/


// output buffaringを開始する
ob_start('_callbackAndFinalize');

// エラーレポートの設定
$errorReportEnabled = dirname(dirname(__FILE__)).'/.error_report';
if(defined($corefilename . '_ERROR_REPORT_ENABLED')){
	$errorReportEnabled = constant($corefilename . '_ERROR_REPORT_ENABLED');
}
if(file_exists($errorReportEnabled)){
	// errorReportEnabledが有効な時は全てのエラーがエラーログに吐出される！
	ini_set('error_reporting', E_ALL);
	ini_set('display_errors', 0);
}

// 共通configurationの読み込み
loadConfig(dirname(__FILE__).'/config.xml');

if(defined($corefilename . '_CONFIG_XML_PATH')){
	// 定義されたconfigureの読み込み
	loadConfig(constant($corefilename . '_CONFIG_XML_PATH'));
}
else {
	// 併設されているconfigureの読み込み
	loadConfig(dirname(__FILE__).'/' . $corefilename . '.config.xml');
}

// パス関連の定数をset_include_pathする
foreach(get_defined_constants() as $constKey => $val){
	if(!preg_match('/.+_INCLUDE_PATH$/',$constKey) && !preg_match('/^PHP_.+_PATH$/',$constKey) && !preg_match('/.+USE.*_PATH$/',$constKey) && preg_match('/.+_PATH$/',$constKey)){
		set_include_path(get_include_path().PATH_SEPARATOR.$val);
	}
}


/*------------------------------ 以下手続き型処理 ココまで ------------------------------*/

?>